---
layout: post
title: "并发简介"
categories:
  - java
tags:
  - 并发
---

摘自于《java并发编程实战》一书，对简介及基础知识部分的一些摘录。

<!-- more -->

## Content
{:.no_toc}

* Will be replaced with the ToC, excluding the "Contents" header
{:toc}

## 摘录
    由于多个线程要共享相同的内存地址空间，并且是并发运行，因此它们可能会访问或修改其他线程正在使用的变量。这实现了数据共享，但是也带来了巨大的风险，幸运的是，java提供了各种同步机制来协同这种访问。  
### 性能问题
   在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作（Context Switch），这种操作将带来极大的开销:保存和恢复执行的上下文，丢失局部性，并且CPU时间将更多地花在线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量。所有这些因素都将带来额外的性能开销。

## 定义
### 无状态
它既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。
> 无状态对象一定是线程安全的。
### 竞态条件
当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。  
最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。  

## 对象共享
synchronized不仅可以实现原子性或者确定“临界区（Critical Section）”，同步还有另一个重要方面：内存可见性（Memmory Visibility）。我们不仅希望个某个线程正在使用对象状态而另一个线程正在修改同时对象状态，而且希望当一个线程修改对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。

### 可见性
在单线程中没有问题，但是在多线程中，当读操作和写操作在不同的线程中执行时，我们无法确保执行读线程的操作能适时地看到其他线程写入的值，有时甚至是根本不可能的事。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。  
在没有同步的情况下，编译器、处理器及运行时等都可能对操作的执行顺序进行一些意想不到的跳转，在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。  
#### 失效数据
指当读线程查看某个变量时，可能得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。  
#### 非原子的64位操作
java内存模型要求：变量的读取操作或写入操作必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作或写操作在不同的线程中执行，那么很有可能读取到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据的问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明他们，或者用锁保护起来。  
#### 加锁与可见性
加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程必须在同一个锁上同步。  
#### Volatile
是一种稍弱的同步机制，确保将变量的更新操作通知到其他线程。volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时总返回最新写入的值。  
volatile变量通常用作某个操作完成、发生中断或者状态的标志。  
当且仅当满足以下条件时，才应该使用volatile变量：
* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。  
* 该变量不会与其他状态变量一起纳入不变性条件中。  
* 在访问变量时不需要加锁。  
> 加锁机制既可以确保可见性又可以确保原子性，但是volatile只能确保可见性。  
