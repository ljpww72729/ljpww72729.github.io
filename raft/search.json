[
  
    {
      "title"    : "Git相关命令",
      "category" : "tutorials",
      "tags"     : "git",
      "url"      : "/tutorials/git%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4.html",
      "date"     : "2018-05-11",
      "excerpt"  : "Git相关命令汇总，平时遇到的一些Git问题整理",
      "content"  : "Git相关命令汇总，平时遇到的一些Git问题整理  目录  配置          查看提交分支树      查看状态        相关命令          找回曾经的的一些提交或已删除的分支      上传本地分支到远程仓库，在远程仓库创建该分支，同时本地跟踪远程分支      创建一个新的仓库，并将本地工程同步到git仓库中        问题汇总          执行git push -u origin master将本地工程同步到GitHub上，报如下错误：      remote: Repository not found.      配置查看提交分支树12git log --graph --oneline --decorate别名：git config --global alias.log-dec &quot;log --graph --oneline --decorate&quot;查看状态12git status -s别名：git config --global alias.st-s &quot;status -s&quot;相关命令找回曾经的的一些提交或已删除的分支12git reflog show：显示提交的历史git reset --hard SHA : SHA为需要恢复的commit对应的SHA值上传本地分支到远程仓库，在远程仓库创建该分支，同时本地跟踪远程分支12git push orign dev-lipeng:dev-lipeng //推送到仓库git branch -u origin/dev-lipeng //跟踪远程分支参考：Git 分支 - 远程分支创建一个新的仓库，并将本地工程同步到git仓库中1234567891011…or create a new repository on the command lineecho &quot;# environment&quot; &amp;gt;&amp;gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/ljpww72729/environment.gitgit push -u origin master…or push an existing repository from the command linegit remote add origin https://github.com/ljpww72729/environment.gitgit push -u origin master问题汇总执行git push -u origin master将本地工程同步到GitHub上，报如下错误：error: src refspec master does not match any.error: failed to push some refs to ‘https://github.com/ljpww72729/location.git’可能的原因：本地并未提交任何代码，所以本地无可提交的分支。remote: Repository not found.fatal: repository ‘https://github.com/WFC-LinkedME/Android-Deep-Linking-SDK.git/’ not found在clone或git的其他操作私有库时，提示如上错误，有几点原因会导致该问题，参考官方帮助文档：https://help.github.com/articles/error-repository-not-found/不过我个人该问题的产生并不是官方中提到的原因，而是升级系统后出现的问题，网上查阅资料并没有有效的解决办法，最后发现是：在执行命令的时候没有自动添加github的帐号和密码，所以没有权限访问该资源，但是明明设置了用户名及密码，并没有起作用，所以只能手动添加用户名及密码。https://username:password@github.com/WFC-LinkedME/Android-Deep-Linking-SDK.git如果git clone 以上链接是没有问题的，也不会报错误。但是现有的AS工程在执行git fetch + 以上链接的时候，虽然没有报错，但是还是无法fetch任何东西下来，因此该方式并不适合已经clone的项目，所以只能另想其他方法，最后在一篇文章中受到启发，修改git库中remote的origin链接。在已clone的库中打开.git/config文件，修改其中remote origin中的url地址，改成手动添加用户名密码的地址。如下所示。 "
    } ,
  
    {
      "title"    : "Aria2配置",
      "category" : "tools",
      "tags"     : "aria2",
      "url"      : "/tools/aria2%E9%85%8D%E7%BD%AE.html",
      "date"     : "2018-04-26",
      "excerpt"  : "aria2配置相关",
      "content"  : "aria2配置相关  目录  配置          启动aria2      关闭aria2      webui配置        相关命令          命令行创建任务下载任务        参考配置参考：http://sspai.com/32167启动aria2aria2c –conf-path=”/Users/LinkedME06/Dropbox/PersonalPreferences/Aria2/aria2.conf” -D关闭aria2如果你想关掉后台的 aria2，可以到活动监视器中找到 aria2c 杀掉，也可以在终端输入kill aria2之后按 Tab 键，aria2 会自动变成进程号，回车即可杀掉它。webui配置查看下载进度使用Aria2 WebUI：  http://ziahamza.github.io/webui-aria2/#  按照图示更改配置后，webui会自动保存配置到浏览器缓存中，下次打开的时候仍会使用更改后的配置，直接显示下载进程。注意一下红色区域：相关命令命令行创建任务下载任务Download from WEB:$ aria2c http://example.org/mylinux.isoDownload from 2 sources:$ aria2c http://a/f.iso ftp://b/f.isoDownload using 2 connections per host:$ aria2c -x2 http://a/f.isoBitTorrent:$ aria2c http://example.org/mylinux.torrentBitTorrent Magnet URI:$ aria2c ‘magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C’Metalink:$ aria2c http://example.org/mylinux.metalinkDownload URIs found in text file:$ aria2c -i uris.txt参考aria2下载地址：https://aria2.github.io/百度网盘下载破解：https://github.com/acgotaku/BaiduExporter下载教程翻译：https://github.com/erasin/notes/blob/master/linux/soft/aria2.md"
    } ,
  
    {
      "title"    : "memcached问题汇总",
      "category" : "tutorials",
      "tags"     : "memcached",
      "url"      : "/tutorials/memcached%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html",
      "date"     : "2018-04-24",
      "excerpt"  : "Jekyll kramdown 语法示例",
      "content"  : "Jekyll kramdown 语法示例  目录  安装          安装问题及解决办法：                  1. memcached no acceptable C compiler found in $PATH          2. can’t run as root without the -u switch          3. telnet: command not found                      参数说明          stats      安装安装参考：高性能缓存库Memcached 基础教程官方安装指南安装问题及解决办法：1. memcached no acceptable C compiler found in $PATH安装gcc:  yum install gcc参考：https://stackoverflow.com/questions/22067913/when-installing-memcached-i-receive-configure-error-no-acceptable-c-compiler2. can’t run as root without the -u switch在执行 memcached -d -p 11211 -m 256 时会报以上错误。说明：如果没有带 -u root 的话就会报：can’t run as root without the -u switch解决：带-u root就行！  memcached -u root -d -p 11211 -m 256参考：https://blog.csdn.net/e_wsq/article/details/200823073. telnet: command not found安装telnet:  yum list telnet*              列出telnet相关的安装包 yum install telnet-server           安装telnet服务 yum install telnet.*            安装telnet客户端参数说明statsstats 是statistics单词的拼写，即统计的意思。该指令攻击当前memcached服务的各种指标。这些指标跟memcached 的性能和工作状况紧密相关。摘自：https://blog.csdn.net/luanlouis/article/details/42425105可通过本机远程获取该stats状态，使用如下命令：  echo stats | nc 192.168.1.123 11211"
    } ,
  
    {
      "title"    : "Android View的可见性检查方法",
      "category" : "android",
      "tags"     : "visible",
      "url"      : "/android/android-view%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E6%A3%80%E6%9F%A5%E6%96%B9%E6%B3%95.html",
      "date"     : "2018-04-18",
      "excerpt"  : "Android View的可见性检查方法，该博客引用自UncleChen的博客，此处只做为备份",
      "content"  : "Android View的可见性检查方法，该博客引用自UncleChen的博客，此处只做为备份  目录  一、背景  二、检查View是否可见的基本方法（从外部检查View）          1. View.getVisibility()      2. View.isShown()      3. View.getGlobalVisibleRect                  关于getGlobalVisibleRect方法的特别说明                    4. View.getLocalVisibleRect      5. 判断手机屏幕是否熄灭or是否解锁        三、ListView、RecyclerView、ScrollView中如何检查View的可见性          1. ScrollView      2. ListView      3. RecyclerView        四、小结  原文链接：Android View的可见性检查方法一、背景在Android开发中有时候会遇到需要检查一个View是不是对用户可见，比如在消息流中，根据ImageView是否在屏幕中出现了再决定加载它，或者当视频滑入屏幕被用户可见时才播放、滑出屏幕就自动停止播放等等。乍一看好像都是在ListView、RecyclerView、ScrollView这些组件里面比较需要做这件事，今天总结一下我在实际开发中是怎么处理View可见性检查的。二、检查View是否可见的基本方法（从外部检查View）1. View.getVisibility()很显然，我们可以用View.getVisibility()来检查一个它是否处于View.VISIBLE状态。这是最基本的检查，如果连这个方法得到的返回值都是View.INVISIBLE或者View.GONE的话，那么它对用户肯定是不可见的。2. View.isShown()这个方法相当于对View的所有祖先调用getVisibility方法。看下它的实现：123456789101112131415161718192021222324    /**     * Returns the visibility of this view and all of its ancestors     *     * @return True if this view and all of its ancestors are {@link #VISIBLE}     */    public boolean isShown() {        View current = this;        //noinspection ConstantConditions        do {            if ((current.mViewFlags &amp;amp; VISIBILITY_MASK) != VISIBLE) {                return false;            }            ViewParent parent = current.mParent;            if (parent == null) {                return false; // We are not attached to the view root            }            if (!(parent instanceof View)) {                return true;            }            current = (View) parent;        } while (current != null);        return false;    }看代码注释便知，这个方法递归地去检查这个View以及它的parentView的Visibility属性是不是等于View.VISIBLE，这样就对这个View的所有parentView做了一个检查。另外这个方法还在递归的检查过程中，检查了parentView == null，也就是说所有的parentView都不能为null。否则就说明这个View根本没有被addView过（比如使用Java代码创建界面UI时，可能会先new一个View，然后根据条件动态地把它add带一个ViewGroup中），那肯定是不可能对用户可见的，这里很好理解。3. View.getGlobalVisibleRect先看下什么是Rect：  Rect holds four integer coordinates for a rectangle. The rectangle is represented by the coordinates of its 4 edges (left, top, right bottom). Rect代表一个矩形，这个矩形可以由它左上角坐标(left, top)、右下角坐标(right, bottom)表示。所以每一个Rect对象里面都有left, top, right bottom这4个属性。使用这个方法的代码非常简单，如下所示，直接可以得到rect对象和方法的返回值visibility：12Rect rect = new Rect();boolean visibility = bottom.getGlobalVisibleRect(rect);看一下该方法的注释：当这个View只要有一部分仍然在屏幕中（没有被父View遮挡，所谓的not clipped by any of its parents），那么将把没有被遮挡的那部分区域保存在rect对象中返回，且方法的返回值是true，即visibility=true。此时的rect是以手机屏幕作为坐标系（所谓的global coordinates），即原点是屏幕左上角；如果它全部被父View遮挡住了或者本身就是不可见的，返回的visibility就为false。123456789101112131415/**     * If some part of this view is not clipped by any of its parents, then     * return that area in r in global (root) coordinates. To convert r to local     * coordinates (without taking possible View rotations into account), offset     * it by -globalOffset (e.g. r.offset(-globalOffset.x, -globalOffset.y)).     * If the view is completely clipped or translated out, return false.     *     * @param r If true is returned, r holds the global coordinates of the     *        visible portion of this view.     * @param globalOffset If true is returned, globalOffset holds the dx,dy     *        between this view and its root. globalOffet may be null.     * @return true if r is non-empty (i.e. part of the view is visible at the     *         root level.     */举例子看一下，先看布局：1234567891011121314&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;                xmlns:tools=&quot;http://schemas.android.com/tools&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot;&amp;gt;    &amp;lt;View        android:layout_width=&quot;100dp&quot;        android:layout_height=&quot;100dp&quot;        android:background=&quot;#0000ff&quot;        android:layout_marginLeft=&quot;-90dp&quot;        android:layout_marginTop=&quot;-90dp&quot;&amp;gt;    &amp;lt;/View&amp;gt;&amp;lt;/RelativeLayout&amp;gt;在xml中定义了一个View，给它设置负值的marginLeft和marginTop，让它只有一部分可以显示在屏幕中。可以看到这个View只有10x10dp大小可以出现在屏幕里面，但是只要有这么点大小可以在屏幕中，上面的方法的返回值就是：visibility=true。执行的效果如下图所示，可以看到100x100dp的蓝色矩形虽然只剩下左上角的10x10dp蓝色小方块可见，但是visibility仍然等于true。此时的GlobalVisibleRect的左上角(left,top)和右下角(right,bottom)分别为(0, 280)和(36, 316)。在这里top不为0是因为标题栏和系统状态栏已经占据了一定的屏幕高度。  tips：这里写代码时测试getGlobalVisibleRect方法时，记得要等View已经绘制完成后，再去调用View的getGlobalVisibleRect方法，否则无法得到的返回值都是0。这和获取View的宽高原理是一样的，如果View没有被绘制完成，那么View.getWidth和View.getHeight一定是等于0的。关于getGlobalVisibleRect方法的特别说明这个方法只能检查出这个View在手机屏幕（或者说是相对它的父View）的位置，而不能检查出与其他兄弟View的相对位置。比如说有一个ViewGroup，下面有View1、View2这两个子View，View1和View2是平级关系。此时如果View2盖住了View1，那么用getGlobalVisibleRect方法检查View1的可见性，得到的返回值依然是true，得到的可见矩形区域rect也是没有任何变化的。也就是说View1.getGlobalVisibleRect(rect)得到的结果与View2没有任何关系。空说无凭，看个具体的例子，先看xml：1234567891011121314151617181920212223242526&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;RelativeLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&amp;gt;    &amp;lt;View        android:id=&quot;@+id/bottom_view&quot;        android:layout_width=&quot;100dp&quot;        android:layout_centerInParent=&quot;true&quot;        android:layout_marginLeft=&quot;-90dp&quot;        android:layout_marginTop=&quot;-90dp&quot;        android:layout_height=&quot;100dp&quot;        android:background=&quot;#0000ff&quot;&amp;gt;    &amp;lt;/View&amp;gt;    &amp;lt;!-- 这里为了看清bottom_view, 给top_view的背景色加了一个透明度 --&amp;gt;    &amp;lt;View        android:id=&quot;@+id/top_view&quot;        android:layout_width=&quot;200dp&quot;        android:layout_height=&quot;200dp&quot;        android:layout_centerInParent=&quot;true&quot;        android:background=&quot;#9000ffff&quot;&amp;gt;    &amp;lt;/View&amp;gt;&amp;lt;/RelativeLayout&amp;gt;这个xml很简单，两个View，分别是下层的bottom_view（100x100dp，在父ViewGroup中居中），top_view（200x200dp，也在父ViewGroup居中，因此可以完全盖住bottom_view）。我们用getGlobalVisibleRect来获取一下bottom_view的visibleRect和visibility，得到的结果是：visibility=true，rect的左上角(left, top)和右下角(right, bottom)是(545, 1161)和(895, 1511)。即使把top_view从xml里面删掉，我们得到visibility和rect也是一样的。所以getGlobalVisibleRect方法并不是万能的，因为它只能检查View和他们的ParentView之间的位置进而判它断是不是在屏幕中可见。  PS：有一次我还想到个奇葩思路，那就是把这个View的兄弟View找出来，也拿出它的GlobalVisibleRect，然后对比兄弟View和这个View的GlobalVisibleRect，看是不是有重合的地方。但是这也只能表明屏幕这一块区域内有两个View，还是无法判断到底是谁遮挡住了谁。4. View.getLocalVisibleRect这个方法和getGlobalVisibleRect有些类似，也可以拿到这个View在屏幕的可见区域的坐标，唯一的区别getLocalVisibleRect(rect)获得的rect坐标系的原点是View自己的左上角，而不是屏幕左上角。先看例子，仍然是使用上面第2个例子的代码，加上下面的代码，执行一下：12Rect localRect = new Rect();boolean localVisibility = bottom.getLocalVisibleRect(localRect);得到的local坐标结果是：localVisibility=true，localRect的左上角(left, top)和右下角(right, bottom)为(0, 0)和(350, 350)。而global坐标的结果是：visibility=true，rect的左上角为(545, 1161)，右下角为(895,1511)。看下getLocalVisibleRect的源码，原来就是先获取View的offset point（相对屏幕或者ParentView的偏移坐标），然后再去调用getGlobalVisibleRect(Rect r, Point globalOffset)方法来获取可见区域，最后再把得到的GlobalVisibleRect和Offset坐标做一个加减法，转换坐标系原点。所以只要这个View的左上角在屏幕中，它的LocalVisibleRect的左上角坐标就一定是(0,0)，如果View的右下角在屏幕中，它的LocalVisibleRect右下角坐标就一定是(view.getWidth(), view.getHeight())。123456789public final boolean getLocalVisibleRect(Rect r) {        final Point offset = mAttachInfo != null ? mAttachInfo.mPoint : new Point();        if (getGlobalVisibleRect(r, offset)) {            r.offset(-offset.x, -offset.y); // make r local            return true;        }        return false;    }5. 判断手机屏幕是否熄灭or是否解锁123456PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);boolean isScreenOn = pm.isScreenOn();boolean isInteractive = pm.isInteractive();// 可能有些版本上面isScreenOn方法隐藏了或者是deprecated了，可以尝试反射调用它，但是要记得用的时候catch异常Method isScreenOnMethod = pm.getClass().getMethod(&quot;isScreenOn&quot;);boolean isScreenOn = (Boolean) isScreenOnMethod.invoke(pm);这里不深究解锁和屏幕是否熄灭的实现方法了，检查View的可见性虽然和屏幕的状态看起来没有直接关系，但是在做检查前先对屏幕的状态做一个检查也是很有必要的，如果屏幕都已经关闭了，那这个View当然是对用户不可见的。三、ListView、RecyclerView、ScrollView中如何检查View的可见性说实话感觉App开发中用得最多的就是各种列表啊、滚动滑动的View。在Android里面这几个可以滚动的View，都有着各自的特点。在用到上面的检测方法时，可以好好结合这几个View的特点，在它们各自的滚动过程中，更加有效的去检查View的可见性。我们可以先根据自己的业务需要，把上面提到的方法封装成一个VisibilityCheckUtil工具类，例如可以提供一个check方法，当View的物理面积有50%可见时，就返回true。1. ScrollView假设我们有一个mView在mScrollView中，我们可以监听mScrollView的滚动，在onScrollChanged中检查mView的可见性。12345678910111213141516171819mScrollView.getViewTreeObserver().addOnScrollChangedListener(        new ViewTreeObserver.OnScrollChangedListener() {          @Override          public void onScrollChanged() {            // 可以先判断ScrollView中的mView是不是在屏幕中可见            Rect scrollBounds = new Rect();            mScrollView.getHitRect(scrollBounds);            if (!mView.getLocalVisibleRect(scrollBounds)) {                return;            }                        // 再用封装好的工具类检查可见性是否大于50%            if (VisibilityCheckUtil.check(mView)) {                // do something            }          }        });2. ListView假设我们在mListView的第10个位置（界面上是第11个item）有一个需要检查可见性的mView。首先要监听mListView的滚动，接着在onScroll回调中，调用mListView.getFirstVisiblePosition和mListView.getLastVisiblePosition查看第10个位置是否处于可见范围，然后在调用封装好的VisibilityCheckUtil去检查mView是否可见。123456789101112131415161718192021mListView.setOnScrollListener(new OnScrollListener() {      @Override      public void onScrollStateChanged(AbsListView view, int scrollState) {        mScrollState = scrollState;      }      @Override      public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,          int totalItemCount) {        if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {          return;        }        int first = mListView.getFirstVisiblePosition();        int last = mListView.getLastVisiblePosition();        // 满足3个条件：先判断ListView中的mView是不是在可见范围中，再判断是不是大于50%面积可见        if (10 &amp;gt;= first &amp;amp;&amp;amp; 10 &amp;lt;= last &amp;amp;&amp;amp; VisibilityCheckUtil.check(mView)) {            // do something        }      }    });3. RecyclerView和上面类似，还是把mView摆放在第10个位置，检查原理和ListView类似。1234567891011121314151617181920mLinearLayoutManager = new LinearLayoutManager(this);mRecyclerView.setLayoutManager(mLinearLayoutManager);mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {      @Override      public void onScrolled(RecyclerView recyclerView, int dx, int dy) {        super.onScrolled(recyclerView, dx, dy);        if (mLinearLayoutManager == null) {          return;        }        int firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition();        int lastVisiblePosition = mLinearLayoutManager.findLastVisibleItemPosition();        // 同样是满足3个条件        if (10 &amp;gt;= firstVisiblePosition &amp;amp;&amp;amp; 10 &amp;lt;= lastVisiblePosition &amp;amp;&amp;amp; VisibilityCheckUtil.check(mView)) {          // do something        }      }    });实际的开发中肯定会遇到更多的场景，我们都要先分析界面的特点，再结合前面提到的几个方法，更有效地检查View的可见性。这里最后再给大家推荐一个开源的项目——VideoPlayerManager，里面就用到getLocalVisibleRect来检测View的可见面积，进而控制在ListView和RecyclerView中哪一个Item应该显示什么内容。四、小结本篇博客的思路，都是从View的外部去检查一个View的可见性。首先提到了一些基本的方法，然后介绍了几种常见的界面下可以怎么使用这些各种方法。如果是App开发者的话，自己写的界面自己去判断View的可见性，有上面这些方法应该就够用了。但是如果你是一个SDK开发者，给App开发者提供第三方的library时（通常是自定义View这类的库），也能够检查开发者的使用到的View，并根据可见性来自动管理一些View的操作，那就非常棒了。这时从外部去检查一个View的可见性可能就不够用了，我们可以换一个角度，从内部去检查一个View的可见性，具体内容详见Android View的可见性检查方法-下篇"
    } ,
  
    {
      "title"    : "jar包中assets文件夹中jar文件反编译",
      "category" : "tools",
      "tags"     : "jar",
      "url"      : "/tools/jar%E5%8C%85%E4%B8%ADassets%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%ADjar%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91.html",
      "date"     : "2018-04-08",
      "excerpt"  : "第三方jar包中的assets文件夹中包含jar文件，如何获取assets中的jar文件并反编译查看源码逻辑",
      "content"  : "第三方jar包中的assets文件夹中包含jar文件，如何获取assets中的jar文件并反编译查看源码逻辑  目录  获取assets文件夹中的jar文件          解压jar文件      解压assets文件夹中的jar文件      反编译classes.dex文件      获取assets文件夹中的jar文件解压jar文件jar文件是将相关文件打包压缩并使用jar作为后缀命名，因此想要获取assets文件夹中的jar文件，需要将jar文件直接用压缩解压软件解压，从而获取assets文件夹中的jar文件。解压后的目录如下图所示：解压assets文件夹中的jar文件同样，将assets文件夹中的jar文件解压，获取classes.dex文件，解压后如下图所示：反编译classes.dex文件使用dex2jar将classes文件反编译成jar文件，然后使用Java Decompiler软件读取jar文件。"
    } ,
  
    {
      "title"    : "redis启动",
      "category" : "config",
      "tags"     : "redis",
      "url"      : "/config/redis%E5%90%AF%E5%8A%A8.html",
      "date"     : "2018-04-02",
      "excerpt"  : "redis启动",
      "content"  : "redis启动  目录  redis启动          开启redis：      连接redis：      redis启动开启redis：在bin目录下执行，启动redis需要指定启动时的配置文件：./redis-server ../conf/redis.conf连接redis：./redis-cli -h 192.168.31.69 -p 22222"
    } ,
  
    {
      "title"    : "emacs快捷方式.",
      "category" : "tools",
      "tags"     : "emacs",
      "url"      : "/tools/emacs%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.html",
      "date"     : "2018-04-01",
      "excerpt"  : "emacs快捷方式汇总",
      "content"  : "emacs快捷方式汇总  目录  基本快捷方式  窗格  插入与删除  文件  缓冲区  自动保存（AUTO SAVE），恢复缓存文件  状态栏（MODE LINE）  搜索  多窗格  多窗口  递归编辑基本快捷方式M ： META 键，如果你没有 META、EDIT 或 ALT 键那么就先按  再按对应的键  C-x C-c 退出 Emacs  C-g  终止一条执行过久的命令，还可以取消数字参数和只输入到一半的命令。  C-v     向前移动一屏  M-v     向后移动一屏  C-l     重绘屏幕，并将光标所在行置于屏幕的中央（注意是 CONTROL-L，不是 CONTROL-1）C-f     向右移动一个字符C-b     向左移动一个字符M-f     向右移动一个词【对中文是移动到下一个标点符号】M-b     向左移动一个词【对中文是移动到上一个标点符号】C-n     移动到下一行C-p     移动到上一行C-a     移动到行首C-e     移动到行尾M-a     移动到句首M-e     移动到句尾“P N B F”四个字母分别代表了四个词，用这四个词记忆这些组合键会更容易：P 代表 previous（上一行），N 代表 next（下一行），B 代表 backward（回退），而 F 则代表 forward（前进）。这些组合键今后将与你形影不离。请注意 C-f 、C-b 和 M-f 、M-b 两对之间的类比关系。通常的惯例是：META 系列组合键用来操作“由语言定义的单位（比如词、句子、段落）”，而 CONTROL系列组合键用来操作“与语言无关的基本单位（比如字符、行等等）”。M-&amp;lt; （META 小于号，按住shift键）可以将光标移动到所有文字的最开头；M-&amp;gt; （META 大于号，按住shift键）可以将光标移动到所有文字的最末尾。C-u 8 C-f 会向前移动 8 个字符C-u 8 C-v 将文本向下滚动 8 行，而不是8屏C-h k C-f 查找C-f快捷键的帮助文档（创建一个新的窗口用于显示帮助文档）C-x 1   只保留一个窗格（也就是关掉其它所有窗格）C-u 0 C-l  将光标所在的行滚动为第一行如果你不小心按了一下 ，你也可以用 C-g 来取消它。  【这个说法似乎有问题，因为按照这个按键顺序输入的应该是 C-M-g。    取消  的正确做法是再连按两次 。】窗格有一系列命令是以 CONTROL-x 开始的，这些命令许多都跟“窗格、文件、缓冲区【缓冲区（buffer）会在后文详细介绍】”等等诸如此类的东西有关，其中有些命令可能包含了 2 个、3 个或者 4 个字符。C-x 1   只保留一个窗格（也就是关掉其它所有窗格）。C-h k C-f  观察当一个新窗格出现时当前窗格（该命令用来显示C-f 命令的帮助文档）是如何缩小的。插入与删除C-u 8 *，这将会插入8个连续的 * 号，重复执行输入字符的命令实际上就是输入多个相同的字符。&amp;lt;DEL&amp;gt;       删除光标前的一个字符C-d          删除光标后的一个字符M-&amp;lt;DEL&amp;gt;     移除光标前的一个词M-d          移除光标后的一个词C-k          移除从光标到“行尾”间的字符M-k          移除从光标到“句尾”间的字符选中某一部分文字：首先把光标移动到你想要移除的区域的一端，然后按 C-&amp;lt;SPC&amp;gt;（&amp;lt;SPC&amp;gt;指空格）【注意，C-&amp;lt;SPC&amp;gt; 往往被中文用户设定成输入法热键，如果这样，C-&amp;lt;SPC&amp;gt; 就被系统拦截而无法传递给 Emacs 了，在这种情况下可以使用C-@。】，然后将光标移动到你准备移除的文字的另一端。这个时候， Emacs 会高亮光标和你按下 C-&amp;lt;SPC&amp;gt; 之间的文本。C-w 剪切复制光标所在的行M-w 复制光标所在的行C-y 粘贴M-y 连续召回：在用 C-y 召回最近移除的文字之后，紧接着再按 M-y 就可以召回再前一次被移除的内容，再按一次 M-y 又可以召回再上一次的……连续使用 M-y 直到找到你想要召回的东西，然什么也不用做，继续编辑就行了。C-/ 撤销文件C-x C-f 输入文件名创建一个缓冲文件 C-x C-f   寻找一个文件 C-x C-s   储存这个文件缓冲区C-x b 显示缓冲区 C-x s   保存多个缓冲区  命令集扩展（EXTENDING THE COMMAND SET） C-x     字符扩展。  C-x 之后输入另一个字符或者组合键。 M-x     命令名扩展。M-x 之后输入一个命令名。 C-x C-z 最大最小话emacsC-x C-b         列出缓冲区。C-x C-c         离开 Emacs。C-x 1           关掉其它所有窗格，只保留一个。C-x u           撤销，以一种git log的简单方式显示当前文档的修改历史，可以回撤到自己想要的文件内容！！替换：replace-string（字符串替换）这个命令，它会把一个字符串替换成另一个。在输入 M-x 之后，Emacs 会在屏幕底端向你询问并等待你输入命令名。如你想输入“replace-string”，其实只需要敲“repl s&amp;lt;TAB&amp;gt;”就行了，Emacs 会帮你自动补齐。输入完之后按 &amp;lt;Return&amp;gt; 提交。注意！！！！只会替换掉光标之后符合条件的字段。 M-% 交互式替换  （暂不清楚如何使用）自动保存（AUTO SAVE），恢复缓存文件如果你已经修改了一个文件，但是还没来得及存盘你的计算机就罢工了，那么你所做的修改就很可能会丢失。为了避免这样的不幸发生，Emacs 会定期将正在编辑的文件写入一个“自动保存”文件中。自动保存文件的文件名的头尾各有一个“#”字符，比如你正在编辑的文件叫“hello.c”，那么它的自动保存文件就叫“#hello.c#”。这个文件会在正常存盘之后被 Emacs 删除。所以，假如不幸真的发生了，你大可以从容地打开原来的文件（注意不是自动保存文件）然后输入 M-x recover file &amp;lt;Return&amp;gt; 来恢复你的自动保存文件。在提示确认的时候，输入 yes&amp;lt;Return&amp;gt;。状态栏（MODE LINE）主模式都是可以用 M-x 启动的扩展命令，M-x fundamental-mode 就可以切换到 Fundamental模式。 Fundamental 模式中，M-f 和 M-b 都将单引号视为分隔单词的符号。M-x text-mode 切换到自然语言文本模式，该模式下，M-f 和 M-b 现在把单引号（’）视为词的一部分。自动折行模式：自动折行（Auto Fill）的辅模式很有用，特别是在编辑自然语言文本的时候。启用自动折行后，Emacs 会在你打字超出一行边界时自动替你换行。用 M-x auto-fill-mode &amp;lt;Return&amp;gt; 启动自动折行模式。再用一次这条命令，自动折行模式会被关闭。也就是说，如果自动折行模式没有被开启，这个命令会开启它；如果已经开启了，这个命令会关闭它。所以我们说，这个命令可以用来“开关（toggle）”模式。搜索C-s 是向前搜索，C-r 是向后搜索。【你会发现 C-g 会让光标回到搜索开始的位置，而 &amp;lt;Return&amp;gt; 则让光标留在搜索结果上，这是很有用的功能。】多窗格C-x 2，它会将屏幕划分成两个窗格。C-x o 将光标移回到其他窗格里，C-x o 可以遍历所有窗格。查找文件并在一个新的窗格打开：输入 C-x 4 C-f，紧跟着输入一个文件名，再用 &amp;lt;Return&amp;gt; 结束。可以看到你指定的文件出现在下方的窗格中，同时光标也跳到了那里。C-x 0	Close current windowC-x 1	Close all windows except the current oneC-x 2	Split current window in two verticallyC-x 3	Split current window in two horizontallyC-x o	Switch to other window多窗口M-x make-frame &amp;lt;Return&amp;gt;。可以看到一个新的窗口出现在了你的屏幕上。 M-x delete-frame &amp;lt;Return&amp;gt;。这个命令将会关闭选中的窗口。 C-x 5 0	Close current frame C-x 5 1	Close all frames except the current one C-x 5 2	Create a new frame递归编辑ESC ESC ESC 离开递归编辑，这是一个最通用的“离开”命令，你甚至可以使用它来关掉多余的窗格，或者离开小缓冲。（赞一个！）你不能用 C-g 退出递归编辑，因为 C-g 的作用是取消“本层递归编辑之内”的命令和其参数（arguments）。其他快捷方式：  格式化代码：C-x h：全选M-x indent-region  在当前行之前加入一空行：C-j  在代码后面添加注释：M+;  替换光标之后的匹配的字符串（注意按住shift）：M+%  多光标C-&amp;lt; 光标向上C-&amp;gt;或C-+ 光标向下  移动光标所在的行向上或向下移动（与mac系统快捷键冲突）M-up或者M-down  以「括号对」为向前、向后跳转光标C-M-p / c-M-n  使用键盘宏 kbd-macro录制宏，例如：C-x ( start-kbd-macroC-n  到下一行C-e  移动到行尾C-S-b  选中最后一个字符C-w  删除之C-x )  end-kbd-macro以上录制了宏，下面调用录制的宏（也可以将宏录制下来保存为函数）：C-x e       执行 1 次刚才录制的宏C-u 5 C-x e 执行 5 次刚才录制的宏，当然也可以执行 1000 遍啦C-u 0 C-x e 也可以执行到buffer end，即执行无限次  输入的lambda转为𝝺字符如何处理？M-x prettify-symbols-mode 从而切换是否转换为𝝺参见：http://ergoemacs.org/emacs/emacs_pretty_lambda.html  从当前光标处换行到下一行M-j或者C-j  在光标所行下插入一新行shift-enter要使用帮助（Help）功能，请先输入 C-h，然后再输入一个字符以说明你需要什么帮助。如果你连自己到底需要什么帮助都不知道，那么就输入 C-h ?，Emacs会告诉你它能提供了哪些帮助。如果你按了 C-h 又想反悔，可以用 C-g 取消。快捷键参考：https://aifreedom.com/technology/112"
    } ,
  
    {
      "title"    : "databinding 使用问题总结",
      "category" : "android",
      "tags"     : "databinding",
      "url"      : "/android/databinding.html",
      "date"     : "2017-04-18",
      "excerpt"  : "对 Databinding 使用过程中发现的问题的总结。",
      "content"  : "对 Databinding 使用过程中发现的问题的总结。  目录  提示          使用资源表达式      NullPointerException      绑定元素                  Two-way Bindings          View Attributes          View References                      注意事项          Included Layouts      提示使用资源表达式可以将dimen相加，如下所示：android:padding=”@{@dim/textPadding + @dim/headerPadding}  可以多次相加，但是在styles中使用无效。参考：Express YourselfNullPointerExceptiondata binding表达式在求值时会检查空指针异常，如果为null，并不会提示NullPointerException，而是设置为null。如下所示：1android:text=&quot;@{user.firstName ?? user.userName}&quot;结果：text值为null。然而，如果求值表达式是在java代码中，则会产生NullPointerException，如下所示：1android:text=”@{com.example.StringUtils.capitalize(user.firstName)}”StringUtils为：123public static String capitalize(String str) {    return Character.toUpperCase(str.charAt(0)) + str.substring(1);}结果：产生NullPointerException。  可通过以下方式引入StringUtils  1234567&amp;lt;data&amp;gt;   &amp;lt;variable       name=&quot;user&quot;       type=&quot;com.example.myapp.model.User&quot;/&amp;gt;   &amp;lt;import       type=&quot;com.example.StringUtils&quot;/&amp;gt;&amp;lt;/data&amp;gt;  绑定元素关于绑定元素这部分可参考：Let’s Flip This ThingTwo-way Bindings使用databinding绑定视图后，对于视图中元素值的变化，尤其是EditText值的变化，需要variable对象中的值也随之变化，就需要采用@={}方式绑定元素值，如下所示：1234&amp;lt;EditText    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;@={user.firstName}&quot;/&amp;gt;View Attributes可以在表达式中获取视图的属性，就像是该属性是model的属性一样，如下所示：12345678910&amp;lt;CheckBox    android:id=&quot;@+id/showName&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;/&amp;gt;&amp;lt;TextView    android:text=&quot;@{user.firstName}&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:visibility=&quot;@{showName.checked ? View.VISIBLE : View.GONE}&quot;    /&amp;gt;  需要使用id来获取相应组件的属性View References在lambda表达式中可以通过视图id来获取该视图的引用：123456789&amp;lt;EditText    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:id=&quot;@+id/firstName&quot;    android:text=&quot;@={user.firstName}&quot; /&amp;gt;&amp;lt;CheckBox    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:onCheckedChanged=&quot;@{()-&amp;gt;handler.checked(firstName)}&quot; /&amp;gt;注意事项Included Layouts采用include嵌套布局时，可以为include设置variable，从而在include布局中直接引用variable值，方法参见：Android Data Binding: Adding some variability中关于’Included Layouts’部分。其中有一点需要注意：123456789101112131415161718192021&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&amp;gt;    &amp;lt;data&amp;gt;        &amp;lt;variable                name=&quot;user&quot;                type=&quot;com.example.myapp.model.User&quot;/&amp;gt;    &amp;lt;/data&amp;gt;    &amp;lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:orientation=&quot;vertical&quot;&amp;gt;        &amp;lt;ImageView                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                android:src=&quot;@{user.image}&quot;/&amp;gt;        &amp;lt;include                layout=&quot;@layout/user_name&quot;                app:user=&quot;@{user}&quot;/&amp;gt;    &amp;lt;/LinearLayout&amp;gt;&amp;lt;/layout&amp;gt;include中app:user=&quot;&quot;的user名称需要与include布局中的variable名称一致，同时使用驼峰命名法命名，不然会出现找不到set方法的错误。正确示例：1app:userInfo=&quot;@{user}&quot;错误示例：1app:user_info=&quot;@{user}&quot;"
    } ,
  
    {
      "title"    : "博客语法示例",
      "category" : "tutorials",
      "tags"     : "jekyll",
      "url"      : "/tutorials/welcome-to-jekyll.html",
      "date"     : "2017-04-09",
      "excerpt"  : "Jekyll kramdown 语法示例",
      "content"  : "Jekyll kramdown 语法示例  目录  示例          显示图片：      显示视频：      显示本地视频：      显示表格：      显示blockquote      显示一个Note      添加注释：      代码片段显示行号      emoji表情      参考文章      示例显示图片：1[![显示图片](/assets/blog/images/201704/logo.jpg &quot;image description&quot;)*My caption*][personal blog]My caption显示视频：123&amp;lt;figure class=&quot;video_container&quot;&amp;gt;&amp;lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/7V-fIGMDsmE&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&amp;lt;/figure&amp;gt;  显示本地视频：12345&amp;lt;figure class=&quot;video_container&quot;&amp;gt;  &amp;lt;video controls=&quot;true&quot; allowfullscreen=&quot;true&quot; poster=&quot;/assets/blog/images/201704/logo.jpg&quot;&amp;gt;    &amp;lt;source src=&quot;/assets/blog/images/201704/movie.mp4&quot; type=&quot;video/mp4&quot;&amp;gt;  &amp;lt;/video&amp;gt;&amp;lt;/figure&amp;gt;        显示表格：12345678910| Default aligned | Left aligned | Center aligned  | Right aligned  ||-----------------|:-------------|:---------------:|---------------:|| First body part | Second cell  | Third cell      | fourth cell    || Second line     | foo          | **strong**      | baz            || Third line      | quux         | baz             | bar            ||-----------------+--------------+-----------------+----------------|| Second body     |              |                 |                || 2nd line        |              |                 |                ||-----------------+--------------+-----------------+----------------|| Third body      |              |                 | Foo            |            Default aligned      Left aligned      Center aligned      Right aligned                  First body part      Second cell      Third cell      fourth cell              Second line      foo      strong      baz              Third line      quux      baz      bar                  Second body                                   2nd line                                       Third body                    Foo      显示blockquote12345678910111213141516171819202122232425&amp;gt; This is a blockquote.&amp;gt;     On multiple lines.That may be lazy.&amp;gt;&amp;gt; This is the second paragraph.----&amp;gt; This is a paragraph.&amp;gt;&amp;gt; &amp;gt; A nested blockquote.&amp;gt;&amp;gt; ### Headers work&amp;gt; {:.no_toc}&amp;gt;&amp;gt; * lists too&amp;gt;&amp;gt; and all other block-level **elements**.&amp;gt;&amp;gt; Even code blocks:&amp;gt;&amp;gt;      def hello&amp;gt;        puts &quot;Hello world!&quot;&amp;gt;      end&amp;gt; {: .language-ruby}  This is a blockquote.    On multiple lines.That may be lazy.  This is the second paragraph.  This is a paragraph.      A nested blockquote.    Headers work      lists too    and all other block-level elements.  Even code blocks:  123 def hello   puts &quot;Hello world!&quot; end  显示一个NoteNote: a note is something that needs to be mentioned but is apart from the context.添加注释：12345This is a paragraph{::comment}This is a comment which is completely ignored.{:/comment}... paragraph continues here.This is a paragraph… paragraph continues here.代码片段显示行号  12345def print_hi(name)  puts &quot;Hi, #{name}&quot;endprint_hi(&#39;Tom&#39;)#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.123456def print_hi(name)  puts &quot;Hi, #{name}&quot;endprint_hi(&#39;Tom&#39;)#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.可通过在_config.yml中配置是否显示行号，如下：12345678910111213141516# kramdown配置说明参见：https://kramdown.gettalong.org/options.htmlkramdown:  # 显示行号参见：https://github.com/jekyll/jekyll/issues/4619#issuecomment-191267346  # 及https://kramdown.gettalong.org/syntax_highlighter/rouge.html  syntax_highlighter: rouge  # Rouge Highlighter in Kramdown › http://kramdown.gettalong.org/syntax_highlighter/rouge.html  # span, block element options fall back to global  syntax_highlighter_opts:    # Rouge Options › https://github.com/jneen/rouge#full-options    css_class: &#39;highlight&#39;    #line_numbers: true # bad idea, spans don&#39;t need linenos and would inherit this option    span:      line_numbers: false    block:      line_numbers: true      start_line: 1emoji表情参考网址：emoji表情I give this plugin two :+1:!  :smirk:参考文章代码高亮的几种选择  不过我只使用了默认的语法高亮"
    } 
  
]
